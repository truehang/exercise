// 在数组中寻找符合条件的子元素，考虑是否可以使用双指针

// 如果是在排序数组中，寻找和为target，那么左指针在头，右指针在尾部，向中间移动，直到相遇

// 如果是寻找和为target，返回的元素值，需要去重，所以先排序一下，
// 寻找三个元素和等于target，先固定一个元素，在剩余范围中需要和为target-nums[i]的元素，总的时间复杂度O2


//如果是在数组中，寻找子数组，那么元素下标需要连续，所以左右指针都在头部，右指针先移动，左指针后移动，
// 可以定位到符合要求的子数组右边界，并且更新值
//数组只包含正整数
for(int r= 0; r < n; ++r)
{
    sum += nums[r];
    while(l <= r && sum > target)
    {
        sum -= nums[l++];
    }
    // 符合要求的子数组
    // 更新答案

}
// 假如数组中有负数，那么我们减去一个数结果并不一定会增大
//所以我们需要保存前缀和，如果以r为右边界的子数组之和为target，前缀和为sum
// 那么前面出现的前缀和应该为sum - target。 
// ||------------sum-------------||
// ||----?----|-------target-----|| <- r
// 所以我们只需要对前缀和进行计数，然后sum - target 的次数即为以r为
// 右边界的数组个数。 
// 值得注意的是，假如sum == target, 那么应该是找到了一个，因为我们找到的个数等于sum - target的个数，
// 那么需要前缀和为0的计数为1，即mp[0] = 1;
// 负数情形的子数组搜索
mp[0] = 1;
for(int r = 0; r < n; ++r)
{
    sum += nums[r];
    if(mp.count(sum - target) > 0)
        cnt += mp[sum - target];
    mp[sum]++;
}

// 寻找符合要求的子字符串也是子数组问题，无非是数组变成了字符数组
// 寻找变位词的子字符串，两点，子数组长度和目标相同，对应字符的出现次数相同
// 所以用一个字符数组对每个字符进行计数。
// 进一步，我们比较targe的字符计数比子字符串字符计数多多少，假如都为0，则找到相同的。
// 同时在移动指针时，移动左指针，对应删除字符，计数减一，但是采取比较的方式，需要加一。

// 回文：双指针来枚举左右边界，可以从中间开始，也可以从两边开始
// 如果只是简单的判断是否是回文，从两边开始向中间比较。
// 如果是统计回文子字符串数量，从中间开始会很简单，因为只要我们往两边走就计数加一，
// 而且我们省去了回文的判断。

