// 和回溯法类似，只不过求最值
// 采用递归思路，把大问题化成小问题

// 单序列问题

//  双序列问题，dp[i,j]表示第一个字符串[0,i],第二个字符串[0,j]的某某条件
// 模板
// 申明矩阵，想好状态转移方程
vector<vector<int>> dp(m + 1, vector<int>(n + 1));
// 初始状态确认
dp[0][0] = x;
// 如果两个之中可以有一个参与，则
for(int i = 0; i < m; ++i)
    dp[i][0] = xxx;
for(int i = 0; i < n; ++i)
    dp[0][i] = xxx;
// 必须有两个参与
for(int i = 0; i < m; ++i)
for(int j = 0; j < n; ++j)
    dp[i][j] = xxx;

// 矩阵路径问题 需要根据到达点坐标的状态找之前的坐标位置

// 背包问题
// 0-1背包问题，某个东西放还是不放
// f[i][j] 在前i个物品选择若干物品放在容量为j的背包的组合数
f[i][j] = f[i - 1][j] + f[i][j - nums[i - 1]];
// 完全背包问题，某种物品可以重复使用，数量不限
// f[i][j]用前i种物品放在容量为j的背包的最少数量
f[i][j] = min(f[i - 1][j - k *nums[i -1]] + k), 0<=k<= j/nums[i - 1]
// 或者枚举j的值
// f[j]为装满容量为j的背包的最少元素个数
f[j] = min(f[j],f[j - nums[i - 1]]);
// f[j] 为组合的总和数
f[j] = sum(dp[i - num[j]]);